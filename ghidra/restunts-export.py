#restunts asm generation
#@author restunts developers
#@category Export
#@keybinding Ctrl-Alt-R
#@menupath Tools.restunts export
#@toolbar
#@runtime Jython

# By default this script expects itself to be stored in the /ghidra folder in
# the restunts repo. If that doesn't suit you, set the path to the root of the
# restunts project dir here. The files produced by this script are placed
# relative to this directory. All required subfolders must be created in
# advance.
PROJECT_DIR_OVERRIDE = ""

# When enabled, every code and data unit will have an end-of-line comment with
# the address and original data bytes which makes it convenient to look up the
# instruction's origin in Ghidra or compare original and produced bytes side
# by side in a disassembly output.
DEBUG = False

# Add ported functions here and re-run the export so that the built assembly
# code will use the C implementation instead.
PORTED_FUNCS_BY_FILE = {
    "math.c": {
        "sin_fast",
        "cos_fast",
    },
}
# Source file by function for quick lookup of whether a function is ported.
PORTED_FUNCS = dict(
    (func, file)
    for file, funcs in PORTED_FUNCS_BY_FILE.iteritems()
    for func in funcs
)

# The original Microsoft CRT that we will not be porting.
CRT_SEG = "seg010"

# The main function is not aliased by default, as we want to set our own main()
# when running unit tests on original functions.
MAIN_FUNC = "stuntsmain"

# Bytes safe to emit inside string literals.
STRING_CHARS = " !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

# Segment override instruction prefixes. Surely it must be possible to detect
# this using some Ghidra API without peeking at the raw bytes?
SEG_PREFIXES = { 0x26:"es", 0x2E: "cs", 0x36: "ss", 0x3E: "ds" }

from zipfile import sizeEndCentDir
from itertools import izip_longest
import inspect
import os.path
import re

from ghidra.program.database.data import DataTypeUtilities
from ghidra.program.model.address import AddressSet
from ghidra.program.model.data import AbstractIntegerDataType, Array, Enum, Pointer, Structure, Union
from ghidra.program.model.lang import OperandType, Register
from ghidra.program.model.listing import CodeUnitFormat, CodeUnitFormatOptions, CommentType, Data, Instruction, LabelString, OperandRepresentationList, VariableFilter, VariableOffset
from ghidra.program.model.scalar import Scalar
from ghidra.program.model.symbol import Equate, SymbolType
from ghidra.app.util import DataTypeDependencyOrderer
from ghidra.app.util.template import TemplateSimplifier
from java.util import ArrayList

script_path = inspect.getsourcefile(lambda:0)
banner = "; Generated by {} (Ghidra)\n".format(os.path.basename(script_path))

prog = currentProgram
if prog is None:
    printerr("No program loaded")

mem = prog.getMemory()
funman = prog.getFunctionManager()
refman = prog.getReferenceManager()
dtman = prog.getDataTypeManager()
bkman = prog.getBookmarkManager()
listing = prog.getListing()
symtab = prog.getSymbolTable()

# restunts repo root.
proj_dir = PROJECT_DIR_OVERRIDE if PROJECT_DIR_OVERRIDE else os.path.normpath(os.path.join(os.path.dirname(script_path), ".."))
# restunts src/ folder.
asm_dir = os.path.normpath(os.path.join(proj_dir, "src/asm"))
dos_dir = os.path.normpath(os.path.join(proj_dir, "src/platform/dos16"))

# Pre-compile utility regexes.
regex_array_mem_operand = re.compile(r'^(.+\.)?([A-Za-z0-9_]+)\[(\d+)\]([\.\+\-\[].+)?$')
regex_nested_array_mem_operand = re.compile(r"([A-Za-z0-9_]+)\[(\d+)\]")

# Add the "_asm_" suffix to function names that can be ported. When building,
# defining the RESTUNTS_ORIGINAL macro will decide whether to map functions
# to their ASM or C implementations.
def func_name_decoration(seg_name, func_name):
    if seg_name != CRT_SEG:
        return func_name + "_asm_"
    else:
        return func_name

###
### Assembly export
###
def write_asm():
    # As close as we can get to WASM syntax with Ghidra's formatter.
    fmt_options = CodeUnitFormatOptions(
        CodeUnitFormatOptions.ShowBlockName.NEVER,
        CodeUnitFormatOptions.ShowNamespace.NEVER,
        "",    # localPrefixOverride
        False, # doRegVariableMarkup
        True,  # doStackVariableMarkup
        False, # includeInferredVariableMarkup
        False, # alwaysShowPrimaryReference
        False, # includeScalarReferenceAdjustment
        True,  # showLibraryInNamespace
        True,  # followReferencedPointers
        TemplateSimplifier()
    )
    fmt = CodeUnitFormat(fmt_options)

    # Ensure we only write 7-bit ASCII to files that will be ingested by archaic tools.
    def ascii(s):
        return s.encode("ascii", errors="ignore")

    ###
    ### Data formatting
    ###

    # Check if the given list of bytes are equal. If None, the data is assumed
    # to be uninitialised and thus equal.
    def is_all_equal(values):
        if values is not None:
            for val in values:
                if val != values[0]: return False
        return True

    # Get component bytes fixed for Java signedness madness.
    def comp_bytes(comp, is_initialised):
        if is_initialised:
            return [b & 0xFF for b in comp.getBytes()]
        else:
            return [ None ] * comp.getLength()

    # Format byte list as little-endian hex value.
    def fmt_bytes(bytes, is_initialised):
        if is_initialised:
            pad_len = len(bytes) * 2
            val = 0
            for b in reversed(bytes):
                val = (val << 8) | b
            return "0x{:0{p}X}".format(val, p=pad_len)
        else:
            return "?"

    # Hex format a single byte value.
    def fmt_byte(b):
        if b is not None:
            return "0x{:02X}".format(b)
        else:
            return "?"

    # Decimal format values <=9, otherwise arbitrary length hex format.
    def fmt_number(value):
        if value is None:
            return "?"
        elif -9 <= value <= 9:
            return str(value)
        else:
            return "0x{:X}".format(value)

    # Primitive type mnemonic by given data's size.
    def fmt_primitive_type(data):
        return { 1: "db", 2: "dw", 4: "dd" }.get(data.getDataType().getLength(), "??")

    # Format scalar as hex, using fixed length values based on the data type's length.
    def fmt_scalar(data, is_initialised, with_mnem):
        if with_mnem:
            return "{} {}".format(fmt_primitive_type(data), fmt_bytes(comp_bytes(data, is_initialised), is_initialised))
        else:
            return fmt_bytes(comp_bytes(data, is_initialised), is_initialised)

    # Format the value of a struct component initialisation (whose data can be uninitialised).
    def fmt_data_component_lines(primitive, comps, per_row, formatter=None):
        def use_formatter(data):
            if data is None:
                return "?"
            elif formatter is not None:
                return formatter(data)
            else:
                return data

        if comps is not None:
            return [
                primitive + " " + ", ".join(use_formatter(c) for c in comps[i:i+per_row])
                    for i in xrange(0, len(comps), per_row)
            ]
        else:
            return [ "?" ]

    # Format a pointer, including segment and symbol, or fallback to raw byte address.
    def fmt_pointer(data, is_initialised, with_mnem):
        ptr_size = data.getDataType().getLength()
        mnem = (fmt_primitive_type(data) + " ") if with_mnem else ""

        if not is_initialised:
            return "{} ?".format(mnem)

        operand = ""
        refs = list(data.getReferencesFrom())
        ref_addr = refs[0].getToAddress() if refs else None
        # We can use the symbol table to get Ghidra's inferred label.
        ref_lbl = symtab.getSymbol(refs[0]).getName() if refs else None
        # ...but if the subscript operator is used, we have to fall back to
        # using the parent label + offset, because WASM treats array indices
        # as byte offsets regardless of the array element's data size.
        #
        # TODO: Is it worth re-using the "sizeof * idx" resolution we utilise
        # in resolve_label_operand() when formatting instruction memory
        # operands?
        if ref_lbl is None or "[" in ref_lbl:
            parent_data = listing.getDataContaining(ref_addr)
            if parent_data is not None:
                ref_lbl = "{}+{}".format(parent_data.getLabel(), fmt_number(ref_addr.subtract(parent_data.getAddress())))
            else:
                ref_lbl = None

        # Only offset.
        if ptr_size == 2:
            if ref_lbl is not None:
                operand = ref_lbl
            else:
                operand = fmt_bytes(comp_bytes(data, is_initialised), is_initialised)
        # Segment and offset.
        elif ptr_size == 4:
            seg_name = mem.getBlock(ref_addr).getName() if refs else None
            if ref_lbl is None:
                operand = fmt_bytes(comp_bytes(data, is_initialised), is_initialised)
            else:
                operand = "{}:{}".format(seg_name, ref_lbl)
        else:
            raise TypeError("Unknown pointer size {}.".format(ptr_size))

        return "{}{}".format(mnem, operand)

    # Strings, escaping unfortunate values as appended raw bytes.
    def fmt_string(data, is_initialised):
        out = []
        if is_initialised:
            cur_str = None
            for ch in comp_bytes(data, is_initialised):
                if chr(ch) in STRING_CHARS:
                    if cur_str is None:
                        cur_str = ""
                    cur_str += chr(ch)
                else:
                    if cur_str is not None:
                        out.append('"' + cur_str + '"')
                        cur_str = None
                    out.append(fmt_number(ch))
            if cur_str is not None:
                out.append('"' + cur_str + '"')
        else:
            out = [ "?" ] * data.getLength()
        return "db " + ", ".join(out)

    # Arrays of any type.
    def fmt_array(data, is_initialised):
        datatype = data.getComponent(0).getDataType()
        bytes = comp_bytes(data, is_initialised)
        if isinstance(datatype, Structure):
            if is_all_equal(bytes):
                # As much as we'd like to output readable statements like
                # TYPE n dup (0), it just doesn't work as soon as there's
                # a bit of nesting or mixed types. Every now and then there
                # will be uninintialised fields, or child fields disappearing
                # entirely. At least WASM doesn't lie about its support for
                # nested initialisation in its manual like TASM does; because
                # WASM doesn't document its syntax at all. So we'll just
                # output unstructured bytes like it's 1988.
                return [ "db {} dup ({})".format(len(bytes), fmt_number(bytes[0])) ]

            return sum([ fmt_data(data.getComponent(i), is_initialised, True) for i in xrange(data.getNumComponents()) ], [])
        else:
            primitive = "db"
            comp_size = 1
            comps = []
            if isinstance(datatype, AbstractIntegerDataType):
                primitive = fmt_primitive_type(data.getComponent(0))
                comp_size = data.getComponent(0).getLength()
                comps = [ fmt_bytes(comp_bytes(data.getComponent(i), is_initialised), is_initialised) for i in xrange(data.getNumComponents()) ]
            # Fallback to raw bytes.
            # TODO: If you are targeting something other than Stunts there could be pointers inside this data that needs to be resolved.
            else:
                comps = bytes
            per_row = 8 / comp_size

            if is_all_equal(comps):
                return [ "{} {} dup ({})".format(primitive, len(comps), comps[0] if is_initialised else "?") ]
            else:
                return fmt_data_component_lines(primitive, comps, per_row, formatter=str)

    # Structs with fields of any type.
    def fmt_struct(data, is_initialised):
        dt = data.getDataType()
        bytes = comp_bytes(data, is_initialised)

        # First we need to figure out if the fields can be structs too, because
        # that is a frequent source of errors where WASM may get the size of
        # the parent struct wrong.
        has_nesting = False
        fields = []
        for i in range(data.getNumComponents()):
            comp = data.getComponent(i)
            if isinstance(comp.getDataType(), (Structure, Array)):
                # Well, it's not like I'd spend the hours wasted on trying to
                # shoehorn in structured data initialisation on something of
                # value anyway.
                has_nesting = True
                break
            else:
                fields += fmt_data(comp, is_initialised, False)

        if is_all_equal(bytes):
            if not is_initialised:
                if not has_nesting:
                    return [ "{} <?>".format(dt.getName()) ]
                else:
                    return [ "db {} dup (?)".format(len(bytes)) ]
            elif bytes[0] == 0:
                return [ "{} <>".format(dt.getName()) ]
            else:
                return [ "db {} dup ({})".format(len(bytes), fmt_number(bytes[0])) ]

        # Fallback to raw bytes.
        # TODO: If you are targeting something other than Stunts there could be pointers inside this data that needs to be resolved.
        if has_nesting:
            return fmt_data_component_lines("db", bytes, 8, formatter=fmt_byte)
        else:
            return [ "{} <{}>".format(dt.getName(), ", ".join(fields)) ]

    # Determine how to format a data code unit.
    def fmt_data(data, is_initialised, with_mnem):
        if data.isArray():
            return fmt_array(data, is_initialised)
        elif data.isStructure():
            return fmt_struct(data, is_initialised)
        elif data.hasStringValue():
            return [ fmt_string(data, is_initialised) ]
        elif data.isPointer():
            return [ fmt_pointer(data, is_initialised, with_mnem) ]
        elif isinstance(data.getDataType(), AbstractIntegerDataType):
            return [ fmt_scalar(data, is_initialised, with_mnem) ]
        else:
            # Everything else as single raw bytes.
            return fmt_data_component_lines("db", comp_bytes(data, is_initialised), 8, formatter=fmt_number)

    ###
    ### Instruction formatting
    ###

    # Replace subscript operator with byte offsets when encountering labels for arrays.
    def resolve_label_operand(operand, addr):
        lbl = str(operand)
        # Short-circuit if there are no subscripts.
        if "[" not in lbl:
            return lbl
        else:
            match = regex_array_mem_operand.match(lbl)
            if match:
                prefix, lbl, idx, suffix = match.groups()

                inner_str = ""
                # "lbl[0]" => "lbl"
                if idx == "0":
                    inner_str = lbl
                else:
                    size = -1

                    # Lookup label to find its base address.
                    symbol = symtab.getSymbols(lbl).next()
                    size = -1
                    if symbol is not None:
                        # Since this must be an array, get the size of its inner type.
                        size = listing.getDefinedDataAt(symbol.getAddress()).getDataType().getDataType().getLength()
                    else:
                        # It must be a struct member that is an array of something.
                        # Assume we have unique member names(!) so that we can Lookup
                        # the member datatype's size.
                        for dt in dtman.getAllDataTypes():
                            if isinstance(dt, Structure):
                                for comp in dt.getComponents():
                                    if comp.getFieldName() == lbl and isinstance(comp.getDataType(), Array):
                                        size = comp.getDataType().getDataType().getLength()
                                        break;
                    if size < 1:
                        raise TypeError("Could not determine size of array element at {}".format(addr))
                    elif size == 1:
                        inner_str = "({}+{})".format(lbl, idx)
                    else:
                        inner_str = "({}+{}*{})".format(lbl, idx, size)

                lbl_str = "{}{}{}".format(prefix or "", inner_str, suffix or "")
                # If there's nesting, assume it is an array of bytes, because
                # that's all we need to deal with for now. And if you arrived
                # here after hours of debugging when trying to adapt this
                # script to your own project; I'm deeply sorry. I didn't think
                # anyone would ever do that.
                if "[" in lbl_str:
                    lbl_str = regex_nested_array_mem_operand.sub(r"(\1+\2)", lbl_str)
                    # Just give up if there are more than two dimensions...
                    if "[" in lbl_str:
                        raise TypeError("Nested array reference operand at {} ({})".format(addr, lbl))
                return lbl_str
            else:
                raise TypeError("No match for \"{}\" at {}".format(lbl, addr))

    # Format operands individually.
    def fmt_operands(code, instr, addr, mnem):
        operands = []

        for op_idx in range(instr.getNumOperands()):
            sep = instr.getSeparator(op_idx)
            if sep: operands.append(sep + " ")
            op_type = instr.getOperandType(op_idx)

            operand = ""

            for op_rep in fmt.getOperandRepresentationList(code, op_idx):
                if isinstance(op_rep, unicode):
                    operand += op_rep
                elif isinstance(op_rep, Register):
                    operand += op_rep.getName().lower()
                elif isinstance(op_rep, Scalar):
                    operand += str(op_rep)
                elif isinstance(op_rep, VariableOffset):
                    operand += op_rep.getVariable().getName()
                    if op_rep.getOffset():
                        operand += "+{}".format(op_rep.getOffset())
                elif isinstance(op_rep, LabelString):
                    operand += resolve_label_operand(op_rep, addr)
                elif isinstance(op_rep, Equate):
                    operand += str(op_rep)
                # Use default formatting for CALL and JMP operands, it's easier to just patch the strings afterwards.
                elif isinstance(op_rep, OperandRepresentationList) and mnem in ["CALL", "JMP"]:
                    operand += str(op_rep)
                else:
                    raise TypeError("Unhandled operand component \"{}\" at {}".format(repr(type(op_rep)), addr))

            # Memory reference operand fixups.
            if mnem in ["MOV", "ADD", "CMP"]:
                # Add "{size_type} ptr" prefix when it is implicit from sibling operand.
                if OperandType.isAddress(op_type) and OperandType.isDynamic(op_type) and " ptr " not in operand:
                    size = 0
                    other_idx = 1 if op_idx == 0 else 0
                    for other_op in instr.getOpObjects(other_idx):
                        if isinstance(other_op, Register):
                            size = other_op.getNumBytes()
                            break
                    operand = "{} ptr {}".format(mem_size_name(size), operand)
                # Add implicit "offset" prefix.
                if mnem != "LEA" and OperandType.isAddress(op_type) and OperandType.isScalar(op_type):
                    operand = "offset " + operand
                # If size is not specified, it must be implicit from a register operand.
                elif 1 == 2 and OperandType.isAddress(op_type) and (operand[0] == "[" or operand[2:4] == ":["):
                    size = 0
                    other_idx = 1 if op_idx == 0 else 0
                    for other_op in instr.getOpObjects(other_idx):
                        if isinstance(other_op, Register):
                            size = other_op.getNumBytes()
                            break

                    operand = "{} ptr {}".format({ 1: "byte", 2: "word", 4: "dword" }.get(size, "?{}?".format(size)), operand)

            operands.append(operand)

        return operands

    # Format instruction code unit.
    def fmt_instruction(code, addr):
        instr = listing.getInstructionAt(addr)
        instr_len = instr.getParsedLength()
        first_byte = instr.getBytes()[0]
        mnem = instr.getMnemonicString()
        insert_nops = 0

        operands = fmt_operands(code, instr, addr, mnem)
        operands_str = "".join(operands).replace(" + ", "+").replace("+-", "-")

        # Second pass fixups after all the operands have been formatted.

        # Ghidra uses CALLF for far calls and CALL for near calls. We add the
        # "near ptr" prefix to the operand for near calls and use the same
        # CALL mnemonic for both.
        if mnem == "CALL" and not " ptr " in operands_str:
            operands_str = "near ptr " + operands_str
        elif mnem == "CALLF":
            mnem = "CALL"
            # When operand is a pointer, it must be 32-bit since it is a far call.
            if not OperandType.isCodeReference(instr.getOperandType(0)):
                seg_override = ""
                # Include the segment prefix if used in the original instruction.
                if first_byte in SEG_PREFIXES:
                    seg_override = SEG_PREFIXES[first_byte] + ":"
                operands_str = "dword ptr " + seg_override + operands_str
            else:
                operands_str = "far ptr " + operands_str
        # Jump operand sizes are implicit in Ghidra.
        elif mnem.startswith("J"):
            if mnem == "JMPF":
                mnem = "JMP"

            # Segment prefixes are usually provided, but not always. We
            # also need to take the prefix into account when checking the
            # instruction length for determining the jump size.
            prefix_len = 0
            seg_override = ""
            if first_byte in SEG_PREFIXES:
                prefix_len = 1
                if ":" not in operands_str:
                    seg_override = SEG_PREFIXES[first_byte] + ":"

            jump_size = ""
            if instr_len - prefix_len == 3:
                jump_size = "near ptr "
            elif instr_len - prefix_len == 5:
                jump_size = "far ptr "

            operands_str = jump_size + seg_override + operands_str
        # Ghidra puts the repeat prefix after the operation mnemonic
        # and explicitly shows the registers as operands. WASM needs
        # the mnemonics flipped and operands cleared.
        elif mnem.endswith(".REP"):
            mnem = "REP " + mnem[:-4]
            operands_str = ""
        elif mnem.endswith(".REPE"):
            mnem = "REPE " + mnem[:-5]
            operands_str = ""
        elif mnem.endswith(".REPNE"):
            mnem = "REPNE " + mnem[:-6]
            operands_str = ""
        # Strip explicit register operands.
        elif mnem in ["CMPSB", "LODSB", "LODSW", "STOSB", "STOSW", "SCASB", "MOVSB", "MOVSW", "XLAT"]:
            operands_str = ""
        # WASM optimises OR si, <=0xFF to three bytes, we must add a NOP to preserve alignment.
        elif mnem == "OR" and operands[0] == "si" and operands[2].startswith("0x") and int(operands[2], 16) <= 0xFF:
            insert_nops = 1

        rows = [ "{:7} {}".format(mnem.lower(), operands_str) ]

        # Insert NOPs if needed for alignment preservation.
        rows += [ "nop\n" ] * insert_nops

        return rows

    ###
    ### Segment formatting
    ###

    # Extract the given <tag> from the comment, returning the comment without
    # the tag and the inner text of the tag
    def parse_patch(comment, tag):
        content = None
        if "<" in comment:
            pattern = re.compile(r"\s*<{tag}>(.*?)</{tag}>\s*".format(tag=tag), re.DOTALL)
            m = pattern.search(comment)
            if m:
                # Superficially format patched code.
                content = ""
                for line in m.group(1).strip().splitlines():
                    line = line.strip()
                    if not line:
                        line.append("")
                    else:
                        comps = line.split(None, 1)
                        content += "    {:7} {}".format(comps[0], comps[1] if len(comps) > 1 else "").rstrip() + "\n"
                # Strip patch from comment.
                comment = pattern.sub("", comment)
        return comment, content

    # Check if given function is far.
    def func_is_far(func):
        return "far" in func.getCallingConventionName()

    # "far" or "near" tag for given function.
    def func_far(func):
        return "far" if func_is_far(func) else "near"

    # Type names for labeled memory references.
    def mem_size_name(size):
        return { 1: "byte", 2: "word", 4: "dword" }.get(size, "byte")

    # Type names for stack variables.
    def var_type_name(dt):
        if isinstance(dt, Array):
            return var_type_name(dt.getDataType())
        else:
            return mem_size_name(dt.getLength()) + " ptr"

    # Types for public data symbols.
    def pub_type_name(data):
        if data is None:
            return "byte"

        type = data.getDataType()

        if isinstance(type, Array):
            return pub_type_name(data.getComponent(0))
        elif isinstance(type, Pointer):
            return mem_size_name(type.getLength())
        elif isinstance(type, Union):
            return "byte"
        else:
            name = type.getName()
            if name in [ "string", "char", "undefined1" ]:
                return "byte"
            else:
                return name

    # Format primitives as db/dw/dd while retaining struct type names.
    def struct_type_name(type):
        if isinstance(type, Structure):
            return type.getName()
        # WASM doesn't support union types.
        elif isinstance(type, Union):
            return "db"
        else:
            return { 1: "db", 2: "dw", 4: "dd" }.get(type.getLength(), "??")

    # Publics in asm and inc files.
    def write_publics(f, block, seg_name, is_extern):
        prefix = "public" if not is_extern else "extrn"
        template = "{name}" if not is_extern else "{name}:{type}"
        addr_start = block.getStart()
        addr_end = block.getEnd()
        syms = []
        funcs = []
        funcs_port = []
        funcs_orig = []

        for s in symtab.getSymbols(AddressSet(addr_start, addr_end), SymbolType.FUNCTION, True):
            func_name = s.getName()
            syms.append((s.getAddress(), template.format(name=func_name_decoration(seg_name, func_name), type="proc")))

            funcs.append(func_name)
            if func_name in PORTED_FUNCS:
                funcs_port.append(func_name)
            else:
                funcs_orig.append(func_name)

        for s in symtab.getSymbols(AddressSet(addr_start, addr_end), SymbolType.LABEL, True):
            name = s.getName()
            data = prog.getListing().getDefinedDataAt(s.getAddress())
            if data is not None or name.startswith("unk_"):
                syms.append((s.getAddress(), template.format(name=name, type=pub_type_name(data))))

        syms.sort()
        for _, symbol in syms:
            f.write("    {} {}\n".format(prefix, symbol))

        if funcs and seg_name != CRT_SEG:
            f.write("\n")
            f.write("    ifdef RESTUNTS_ORIGINAL\n")
            f.write("        ; Alias all functions to the original asm implementation.\n")
            for func_name in funcs:
                # Except stuntsmain()...
                if func_name == MAIN_FUNC:
                    f.write("        extrn {}:proc\n".format(func_name))
                else:
                    f.write("        {} = {}\n".format(func_name, func_name_decoration(seg_name, func_name)))
            f.write("    else\n")
            if funcs_orig:
                f.write("        ; Alias unported functions to the original asm implementation.\n")
            for func_name in funcs_orig:
                if func_name == MAIN_FUNC:
                    f.write("        extrn {}:proc\n".format(func_name))
                else:
                    f.write("        {} = {}\n".format(func_name, func_name_decoration(seg_name, func_name)))
            if funcs_port:
                f.write("        ; Functions ported to C are external.\n")
            for func_name in funcs_port:
                if func_name != MAIN_FUNC:
                    f.write("        extrn {}:proc\n".format(func_name))
            f.write("    endif\n")

    # Segment declaration in asm and inc files.
    def seg_decl(block, is_data):
        seg_name = block.getName()
        seg_class = None
        if is_data:
            seg_class = "STUNTSD"
        else:
            seg_class = "STUNTSC"
        return "{} segment byte public use16 '{}'\n".format(seg_name, seg_class)

    # A segment's accompanying definitions file with its publics to be used by
    # other segment's asm file.
    def write_def(block, seg_name, is_data):
        with open(os.path.join(asm_dir, seg_name + ".def"), "w") as f:
            f.write(banner)
            f.write(seg_decl(block, is_data))
            write_publics(f, block, seg_name, True)
            f.write("{} ends\n".format(seg_name))

    # A segment's accompanying include file to keep the verbose includes,
    # publics and aliases/externs for porting separated from the code.
    def write_inc(block, seg_name, is_data):
        with open(os.path.join(asm_dir, seg_name + ".inc"), "w") as f:
            f.write(banner)
            f.write("include custom.inc\n")
            f.write("include structs.inc\n")
            for ib in mem.getBlocks():
                iname = ib.getName()
                # Skip stack which has nothing to include.
                if ib != block and iname != "dsegs":
                    f.write('include {}.def\n'.format(ib.getName()))
            f.write("\n")
            f.write(seg_decl(block, is_data))
            write_publics(f, block, seg_name, False)
            f.write("{} ends\n".format(seg_name))

    # Format a segment as Watcom compatible 8086 assembly.
    def write_segment(block):
        is_start = False
        is_data = False
        is_initialised = block.isInitialized()
        seg_name = block.getName()
        seg_comment = block.getComment()

        # We store data segment properties in Ghidra's block comment field.
        if seg_comment:
            # Skip stack, we handcraft it in custom.asm.
            if seg_comment.startswith("STACK"):
                return
            is_data = seg_comment.startswith(("DATA", "BSS"))

        # Must print some progress since it's so slow.
        print(seg_name)

        write_def(block, seg_name, is_data)
        write_inc(block, seg_name, is_data)

        with open(os.path.join(asm_dir, seg_name + ".asm"), "w") as f:
            f.write(banner)
            f.write(".8086\n")
            f.write(".model medium\n\n")
            f.write("include {}.inc\n\n".format(seg_name))

            # Group DATA and BSS.
            if seg_name.startswith("dseg"):
                f.write("DGROUP group {}\n\n".format(seg_name))

            f.write(seg_decl(block, is_data))
            f.write("    assume cs:{}, es:nothing, ss:nothing, ds:dseg\n\n".format(seg_name))

            start_addr = block.getStart()
            func = None
            func_name = ""

            # Iterate through and format every code unit in the block.
            unit = listing.getCodeUnitAt(start_addr)
            while unit is not None and unit.getAddress() <= block.getEnd():
                addr = unit.getAddress()

                # Left previous function.
                if func and addr > func.getBody().getMaxAddress():
                    f.write("{} endp\n".format(func_name))
                    func = None
                    func_name = ""

                # Comments.
                comment_plate  = unit.getCommentAsArray(CommentType.PLATE) or None
                comment_repeat = unit.getCommentAsArray(CommentType.REPEATABLE) or None
                comment_pre    = unit.getCommentAsArray(CommentType.PRE) or None
                comment_post   = unit.getCommentAsArray(CommentType.POST) or None
                comment_eol    = unit.getCommentAsArray(CommentType.EOL) or None

                # Extract patch directives from comments.
                patch_insert = None
                patch_replace = None
                patch_nop = False
                patch_delete = False

                if comment_pre:
                    comment_tmp = "\n".join(comment_pre)
                    comment_tmp, patch_insert = parse_patch(comment_tmp, "INSERT")
                    comment_tmp, patch_replace = parse_patch(comment_tmp, "REPLACE")
                    if patch_insert and patch_replace:
                        raise SyntaxError("INSERT and REPLACE patch tags combined at {}.".format(addr))
                    comment_pre = comment_tmp.splitlines()
                if comment_eol:
                    comment_tmp = "\n".join(comment_eol)
                    if "<NOP>" in comment_tmp:
                        patch_nop = True
                        comment_tmp = comment_tmp.replace("<NOP>", "")
                    if "<DELETE>" in comment_tmp:
                        patch_delete = True
                        comment_tmp = comment_tmp.replace("<DELETE>", "")
                    comment_eol = comment_tmp.strip().splitlines()

                # Write plate and pre comments before a potential function header.
                if comment_plate:
                    f.write("\n; {}\n".format("*" * 78))
                    for l in comment_plate:
                        f.write("; * {}\n".format(ascii(l)))
                    f.write("; {}\n".format("*" * 78))
                if comment_pre:
                    for l in comment_pre:
                        f.write("; {}\n".format(ascii(l)))

                # Start of a function.
                begin_func = funman.getFunctionAt(addr)
                if begin_func:
                    # Close previous function.
                    if func:
                        f.write("{} endp\n".format(func_name))

                    func = begin_func
                    func_name = func_name_decoration(seg_name, func.getName())
                    if func_name == "start":
                        is_start = True

                    if addr != start_addr:
                        f.write("\n")
                    f.write("; {}\n".format(func.getPrototypeString(True, True)))
                    f.write("{} proc {}\n".format(func_name, func_far(func)))

                    # Declare stack variables.
                    vars = []
                    for v in func.getVariables(VariableFilter.STACK_VARIABLE_FILTER):
                        var_name = v.getName()
                        var_dt = var_type_name(v.getDataType())
                        var_ofs = v.getStackOffset() + 2
                        vars.append((var_ofs, "    {:10} = {:9} {:3}".format(var_name, var_dt, var_ofs)))

                    vars.sort(key=lambda x: x)
                    for _, v in vars:
                        f.write(v + "\n")
                    if vars:
                        f.write("\n")

                label = unit.getLabel()
                # Ignore label if we already wrote it in the function header.
                if label and begin_func:
                    label = None
                # Label on preceding line in code segments or patched data unit.
                elif label and (not is_data or patch_insert or patch_replace):
                    f.write(label + ":\n")
                    label = None

                # Write patched code.
                if patch_insert:
                    f.write("; <INSERT>\n")
                    f.write(patch_insert)
                    f.write("; </INSERT>\n")
                if patch_replace:
                    f.write("; <REPLACE>\n")
                    f.write(patch_replace)
                    f.write("; </REPLACE>\n")
                if patch_nop and is_initialised:
                    # Insert a NOP for every byte in the original instruction.
                    f.write("; <NOP>\n")
                    f.write("    nop\n" * unit.getLength())
                    f.write("; </NOP>\n")
                if patch_delete:
                    f.write("; <DELETE>\n")

                if isinstance(unit, Data):
                    rows = fmt_data(unit, is_initialised, True)

                elif isinstance(unit, Instruction):
                    rows = fmt_instruction(unit, addr)

                # Combine comments to be shown at end of line.
                comments = (list(comment_eol) if comment_eol is not None else []) + (list(comment_repeat) if comment_repeat is not None else [])

                # Show address, original bytes and original disassembly at end of line when debugging.
                if DEBUG:
                    bytes = " ".join(["{:02X}".format(b & 0xFF) for b in unit.getBytes()]) if is_initialised else "?"
                    comments.insert(0, "{}  {:14} {}".format(addr, bytes, fmt.getRepresentationString(unit)))

                # Merge label, code/data and comment/debug info.
                for l, r, c in izip_longest([label], rows, comments):
                    if l is None: l = ""
                    if r is None: r = ""
                    # Merge rows and comment.
                    if c is not None:
                        r = "{:42} ; {}".format(r, ascii(c))

                    # Merge label and row.
                    r = "{:20} {}".format(l, r) if is_data else "    {}".format(r)

                    # Comment out entire code line due to patching.
                    if patch_replace is not None or patch_nop or patch_delete:
                        r = ";" + r
                    f.write(r.rstrip() + "\n")

                if comment_post:
                    for l in comment_post:
                        f.write("; {}\n".format(ascii(l)))

                unit = listing.getCodeUnitAfter(addr)

            # Close function at end of segment.
            if func_name:
                f.write("{} endp\n\n".format(func_name))
                func = None
                func_name = ""

            f.write("{} ends\n".format(seg_name))
            if is_start:
                f.write("end start\n")
            else:
                f.write("end\n")

    # Stack and empty helper segment for determining the end of the executable.
    def write_custom():
        filename_inc = "custom.inc"
        print("Writing {}...".format(filename_inc))
        with open(os.path.join(asm_dir, filename_inc), "w") as f:
            f.write(banner)
            f.write("\n")
            f.write("; This empty segment is placed at the end of the executable. It is used\n")
            f.write("; by the hacked CRT in seg010.asm to determine how large the image is.\n")
            f.write("endseg segment byte public 'ENDSEG' use16\n")
            f.write("endseg ends\n")

        filename_asm = "custom.asm"
        print("Writing {}...".format(filename_asm))
        with open(os.path.join(asm_dir, filename_asm), "w") as f:
            f.write(banner)
            f.write("\n")
            f.write(".8086\n")
            f.write(".model medium\n")
            f.write("\n")
            f.write("dsegs segment byte public use16 'STACK'\n")
            f.write("    db 8000 dup (?)\n")
            f.write("dsegs ends\n")
            f.write("\n")
            f.write("end\n")

    # Struct components (and union, had they been supported by WASM).
    def write_type_components(f, components):
        for c in components:
            comment = c.getComment()
            is_array = isinstance(c.getDataType(), Array)
            count = 0
            type = None
            if is_array:
                count = c.getDataType().getNumElements()
                type = DataTypeUtilities.getBaseDataType(c.getDataType())
            else:
                type = c.getDataType()
            is_struct = isinstance(type, Structure)
            suffix = "<>" if is_struct else "?"
            mnem = struct_type_name(type)
            typestr = ""
            if is_array:
                typestr = "{} {} dup ({})".format(mnem, count, suffix)
            else:
                typestr = "{} {}".format(mnem, suffix)

            basestr = "    {:18} {}".format(c.getFieldName(), typestr)

            if comment:
                lines = comment.splitlines()
                f.write("{:42} ; {}\n".format(basestr, lines[0]))
                for l in lines[1:]:
                    f.write("{:42} ; {}\n".format("", l))
            else:
                f.write(basestr + "\n")

    # Include file for custom data types.
    def write_structs():
        filename = "structs.inc"
        print("Writing {}...".format(filename))
        with open(os.path.join(asm_dir, filename), "w") as f:
            f.write(banner)
            f.write("\n")
            for dt in DataTypeDependencyOrderer(dtman, ArrayList(list(dtman.getAllDataTypes()))).getDependencyList():
                # Skip these register types which we can't use due to lack of union support in WASM.
                if dt.getName() in ["REGS", "BYTEREGS", "WORDREGS"]:
                    continue

                # Category and description as preceding comment.
                if isinstance(dt, (Enum, Structure, Union)):
                    # clib types that we don't care about will have the header filename as their category.
                    category = dt.getCategoryPath().getName()
                    if category:
                        f.write("; {}\n".format(category))

                    description = dt.getDescription()
                    if description:
                        f.write("; Description: {}\n".format(description))

                if isinstance(dt, Structure):
                    f.write("{} struc\n".format(dt.getName()))
                    write_type_components(f, dt.getComponents())
                    f.write("{} ends\n\n".format(dt.getName()))
                elif isinstance(dt, Enum):
                    f.write("; enum {}\n".format(dt.getName()))
                    for name in dt.getNames():
                        f.write("{:12} = 0x{:02X}\n".format(name, dt.getValue(name)))
                    f.write("\n")
                elif isinstance(dt, Union):
                    raise TypeError("Union types not supported by WASM.")

    print("Writing asm files to {}...".format(asm_dir))
    write_custom()
    write_structs()

    print("Generating segments...")
    for block in mem.getBlocks():
        write_segment(block)

###
### Link file aliases
###
def write_lnk():
    # We can't have public function equates, so we make link aliases instead
    # to make the unported assembly functions callable from C.
    def write_aliases(filename, aliases):
        with open(os.path.join(dos_dir, filename), "w") as f:
            f.write(banner.replace(";", "#") + "\n")
            f.write("ALIAS ")
            f.write(",\n      ".join(aliases))
            f.write("\n")

    print("Writing lnk files to {}...".format(dos_dir))
    funcs_orig = []
    funcs_port = []

    for func in funman.getFunctions(True):
        seg_name = mem.getBlock(func.getEntryPoint()).getName()
        if seg_name == CRT_SEG:
            continue

        func_name = func.getName()
        alias = "{} = {}".format(func_name, func_name_decoration(seg_name, func_name))

        # Don't include stuntsmain for original builds, we set it at link-time
        # instead, that way we can test original functions with our own main().
        if func_name != MAIN_FUNC:
            funcs_orig.append(alias)

            if func_name not in PORTED_FUNCS:
                funcs_port.append(alias)

    write_aliases("aliases-orig.lnk", funcs_orig)
    write_aliases("aliases-port.lnk", funcs_port)

write_asm()
write_lnk()
print("Anders rules!") # The real MVP.
