; Generated by restunts-export.py (Ghidra)
.8086
.model medium

include seg029.inc

seg029 segment byte public use16 'STUNTSC'
    assume cs:seg029, es:nothing, ss:nothing, ds:dseg

    db 0x90
    db 0
    db 0
; compares two 4 bytes optionally case sensitive chunk names 
; returns 1 if the chunk names are equal, 0 if not  

; bool __cdecl16far audioresource_compare_chunknames(int case_sensitive, byte * chunk_name, byte * found_name, int num)
audioresource_compare_chunknames_asm_ proc far
    var_2      = word ptr   -2
    case_sensitive = word ptr    6
    chunk_name = dword ptr   8
    found_name = dword ptr  12
    num        = word ptr   16

    push    bp
    mov     bp, sp
    sub     sp, 0x2
    push    di
    push    si
    cmp     word ptr [bp+num], 0x0
    jz      LAB_39ad_0080
    mov     di, word ptr [bp+case_sensitive]
    mov     si, word ptr [bp+num]
LAB_39ad_0018:
    les     bx, [bp+chunk_name]
    cmp     byte ptr es:[bx], 0x0
    jz      LAB_39ad_007d                      ; goto end
    les     bx, [bp+found_name]
    cmp     byte ptr es:[bx], 0x0
    jz      LAB_39ad_007d                      ; goto end
    or      di, di
    jz      LAB_39ad_0046
    mov     al, byte ptr es:[bx]               ; al = arg_foundname[]
    les     bx, [bp+chunk_name]
    cmp     byte ptr es:[bx], al
    jz      LAB_39ad_0046
LAB_39ad_0039:
    sub     ax, ax
    mov     word ptr [bp+num], si
    pop     si
    pop     di
    mov     sp, bp
    pop     bp
    retf
    db 2 dup (0x90)
LAB_39ad_0046:
    or      di, di
    jnz     LAB_39ad_0074
    les     bx, [bp+found_name]
    mov     al, byte ptr es:[bx]
    sub     ah, ah
    push    ax
    call    far ptr toupper
    add     sp, 0x2
    les     bx, [bp+chunk_name]
    mov     cl, byte ptr es:[bx]
    sub     ch, ch
    push    cx
    mov     word ptr [bp+var_2], ax
    call    far ptr toupper
    add     sp, 0x2
    cmp     ax, word ptr [bp+var_2]
    jnz     LAB_39ad_0039
LAB_39ad_0074:
    inc     word ptr [bp+chunk_name]
    inc     word ptr [bp+found_name]
    dec     si
    jnz     LAB_39ad_0018
LAB_39ad_007d:
    mov     word ptr [bp+num], si
LAB_39ad_0080:
    mov     ax, 0x1
    pop     si
    pop     di
    mov     sp, bp
    pop     bp
    retf
audioresource_compare_chunknames_asm_ endp
    db 0x90
; returns the index of a specified 4 byte chunk name in an array of 4 bytes chunk names  

; int __cdecl16far audioresource_get_chunk_index(int num, int numchunks, char * chunkname, byte * chunkptr)
audioresource_get_chunk_index_asm_ proc far
    var_chunkname = word ptr  -14
    var_chunknameseg = word ptr  -12
    var_A      = word ptr  -10
    var_counter = word ptr   -8
    var_namebuf = byte ptr   -6
    var_2      = byte ptr   -2
    num        = word ptr    6
    numchunks  = word ptr    8
    chunkname  = word ptr   10
    chunkptr   = dword ptr  12

    push    bp
    mov     bp, sp
    sub     sp, 0xe
    push    di
    push    si
    mov     byte ptr [bp+var_2], 0x0
    mov     word ptr [bp+var_counter], 0x0
    cmp     word ptr [bp+numchunks], 0x0
    jle     LAB_39ad_0103
    mov     ax, word ptr [bp+chunkname]
    mov     word ptr [bp+var_chunkname], ax
    mov     word ptr [bp+var_chunknameseg], ds
    mov     si, word ptr [bp+var_counter]
LAB_39ad_00ad:
    sub     cx, cx
    les     di, [bp+chunkptr]
LAB_39ad_00b2:
    mov     bx, cx
    add     bx, bp
    mov     al, byte ptr es:[di]
    mov     byte ptr [bx-0x6], al
    inc     di
    inc     cx
    cmp     cx, 0x4
    jl      LAB_39ad_00b2
; ; loops 4 times - for each character in the chunk name 
;   
    mov     word ptr [bp+chunkptr], di         ; point at next chunk name
    mov     word ptr [bp+chunkptr+2], es
    mov     word ptr [bp+var_A], cx
    mov     ax, 0x4
    push    ax
    push    word ptr [bp+var_chunknameseg]
    push    word ptr [bp+var_chunkname]
    lea     ax, [bp+var_namebuf]
    push    ss
    push    ax
    sub     ax, ax
    push    ax
    push    cs
    call    near ptr audioresource_compare_chunknames
    add     sp, 0xc
    or      ax, ax
    jz      LAB_39ad_00f4                      ; if ax = 0, then try next
    mov     ax, si
    mov     word ptr [bp+var_counter], si
    pop     si
    pop     di
    mov     sp, bp
    pop     bp
    retf
LAB_39ad_00f4:
    mov     ax, word ptr [bp+num]
    add     word ptr [bp+chunkptr], ax
    inc     si
    cmp     si, word ptr [bp+numchunks]
    jl      LAB_39ad_00ad
    mov     word ptr [bp+var_counter], si
LAB_39ad_0103:
    mov     ax, 0xffff
    pop     si
    pop     di
    mov     sp, bp
    pop     bp
    retf
audioresource_get_chunk_index_asm_ endp

; word __cdecl16far audioresource_find(void * data, char * chunkname)
audioresource_find_asm_ proc far
    var_chunkindex = word ptr  -16
    var_E      = word ptr  -14
    var_C      = word ptr  -12
    var_A      = word ptr  -10
    var_8      = word ptr   -8
    var_6      = word ptr   -6
    var_4      = word ptr   -4
    var_numchunks = word ptr   -2
    data       = dword ptr   6
    chunkname  = word ptr   10

    push    bp
    mov     bp, sp
    sub     sp, 0x10
    sub     ax, ax
    mov     word ptr [bp+var_8], ax
    mov     word ptr [bp+var_A], ax
    mov     ax, 0x4
    cwd
    add     ax, word ptr [bp+data]
    adc     dx, 0x0
    mov     cx, 0xc
    shl     dx, cl
    add     dx, word ptr [bp+data+2]
    mov     es, dx
    mov     bx, ax
    mov     ax, word ptr es:[bx]               ; read a word from songfile+4 = number of (sub)chunks?
    mov     word ptr [bp+var_numchunks], ax
    mov     ax, 0x6
    cwd
    add     ax, word ptr [bp+data]
    adc     dx, 0x0
    shl     dx, cl
    add     dx, word ptr [bp+data+2]
    push    dx
    push    ax                                 ; songfile+6 = chunknames
    push    word ptr [bp+chunkname]
    push    word ptr [bp+var_numchunks]
    sub     ax, ax
    push    ax
    push    cs
    call    near ptr audioresource_get_chunk_index
    add     sp, 0xa
    mov     word ptr [bp+var_chunkindex], ax
    or      ax, ax
    jl      LAB_39ad_01aa                      ; -1 = not found
    mov     ax, word ptr [bp+data]
    mov     dx, word ptr [bp+data+2]
    mov     cx, word ptr [bp+var_numchunks]
    shl     cx, 0x1
    shl     cx, 0x1
    add     ax, cx
    mov     cx, word ptr [bp+var_chunkindex]
    shl     cx, 0x1
    shl     cx, 0x1
    add     ax, cx
    add     ax, 0x6
    mov     word ptr [bp+var_6], ax            ; ax = chunkofs + 6 + (chunkindex << 2) + (numchunk << 2)
    mov     word ptr [bp+var_4], dx
    push    dx
    push    ax
    call    far ptr audioresource_get_dword    ; read dword from the audio resource buffer
    add     sp, 0x4
    mov     word ptr [bp+var_E], ax
    mov     word ptr [bp+var_C], dx
    mov     ax, word ptr [bp+data]
    mov     dx, word ptr [bp+data+2]
    mov     bx, word ptr [bp+var_numchunks]
    mov     cl, 0x3
    shl     bx, cl
    add     ax, bx
    add     ax, word ptr [bp+var_E]
    add     ax, 0x6
    mov     word ptr [bp+var_A], ax            ; ax = chunkofs + 6 + readdword + (numchunks << 3)
    mov     word ptr [bp+var_8], dx
LAB_39ad_01aa:
    mov     ax, word ptr [bp+var_A]
    mov     dx, word ptr [bp+var_8]
    mov     sp, bp
    pop     bp
    retf
audioresource_find_asm_ endp

; undefined __cdecl16far audioresource_copy_n_bytes(void * srcptr, void * dstptr, int count)
audioresource_copy_n_bytes_asm_ proc far
    var_6      = word ptr   -6
    var_2      = word ptr   -2
    srcptr     = dword ptr   6
    dstptr     = dword ptr  10
    count      = word ptr   14

    push    bp
    mov     bp, sp
    sub     sp, 0x6
    push    di
    push    si
    mov     word ptr [bp+var_2], 0x0
    cmp     word ptr [bp+count], 0x0
    jle     LAB_39ad_01f4
    mov     cx, word ptr [bp+count]
    mov     ax, cx
    add     word ptr [bp+var_2], ax
    les     di, [bp+dstptr]
    mov     word ptr [bp+var_6], ds
    lds     si, [bp+srcptr]
LAB_39ad_01d8:
    mov     al, byte ptr [si]
    mov     byte ptr es:[di], al
    mov     ax, si
    mov     dx, ds
    inc     si
    inc     di
    loop    LAB_39ad_01d8
    mov     word ptr [bp+srcptr], si           ; ??
    mov     word ptr [bp+srcptr+2], ds         ; ??
    mov     ds, word ptr [bp+var_6]
    mov     word ptr [bp+dstptr], di           ; ??
    mov     word ptr [bp+dstptr+2], es         ; ??
LAB_39ad_01f4:
    pop     si
    pop     di
    mov     sp, bp
    pop     bp
    retf
audioresource_copy_n_bytes_asm_ endp

seg029 ends
end
